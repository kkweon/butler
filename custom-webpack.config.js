const HtmlWebpackPlugin = require('html-webpack-plugin')
const WebpackShellPluginNext = require('webpack-shell-plugin-next')
const CopyWebpackPlugin = require('copy-webpack-plugin')

const basePlugins = [
  new CopyWebpackPlugin({
    patterns: [
      {
        from: 'src/manifest.json',
        to: 'manifest.json', // Output path is relative to webpack's output.path (dist/butler)
      },
    ],
  }),
  new HtmlWebpackPlugin({
    filename: 'options.html',
    template: './src/options.html',
    chunks: ['options', 'polyfills', 'styles', 'vendor'], // Ensure necessary chunks are included
    // polyfills, styles, vendor chunks are typically generated by Angular
  }),
]

// Determine if running in watch mode by checking process.argv
const isWatchMode = process.argv.includes('--watch');

if (process.env.RUN_UPDATE_MANIFEST === 'true') {
  const shellPluginOptions = {};

  if (isWatchMode) {
    console.log('Configuring WebpackShellPluginNext for watch mode (onDoneWatch).');
    shellPluginOptions.onDoneWatch = {
      scripts: ['bash scripts/update-manifest.sh'],
      blocking: true, // Ensures webpack waits for the script to finish
      parallel: false,
    };
  } else {
    console.log('Configuring WebpackShellPluginNext for single build (onBuildEnd).');
    // onBuildEnd fires after files are emitted at the end of the compilation.
    shellPluginOptions.onBuildEnd = {
      scripts: ['bash scripts/update-manifest.sh'],
      blocking: true,
      parallel: false,
    };
  }
  basePlugins.push(new WebpackShellPluginNext(shellPluginOptions));
}

module.exports = {
  entry: {
    // 'main' entry is handled by Angular CLI's default webpack config
    // We only need to define additional entry points.
    options: './src/main.options.ts',
  },
  plugins: basePlugins,
}
